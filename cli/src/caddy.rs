//! Caddy configuration generator for tenement
//!
//! Generates Caddyfile for automatic HTTPS reverse proxy to tenement.

use anyhow::{Context, Result};
use std::path::PathBuf;
use std::process::Command;

/// Default Caddyfile path
const CADDYFILE_PATH: &str = "/etc/caddy/Caddyfile";

/// Generate Caddyfile content for reverse proxying to tenement
pub fn generate_caddyfile(domain: &str, port: u16) -> String {
    format!(
        r#"# Tenement reverse proxy configuration
# Generated by: ten caddy --domain {domain} --port {port}
#
# Features:
# - Automatic HTTPS via Let's Encrypt
# - Wildcard subdomain routing (*.{domain})
# - HTTP to HTTPS redirect
#
# Usage:
#   caddy run                    # Run in foreground
#   caddy start                  # Run as daemon
#   caddy reload                 # Reload config
#   systemctl restart caddy      # If using systemd

# Main domain and wildcard subdomains
{domain}, *.{domain} {{
    # Reverse proxy to tenement
    reverse_proxy localhost:{port}

    # Enable compression
    encode gzip zstd

    # Logging
    log {{
        output file /var/log/caddy/{domain}.log {{
            roll_size 100mb
            roll_keep 5
        }}
    }}
}}
"#
    )
}

/// Generate a minimal Caddyfile (no logging, simpler)
pub fn generate_caddyfile_minimal(domain: &str, port: u16) -> String {
    format!(
        r#"# Tenement reverse proxy (minimal)
# Generated by: ten caddy --domain {domain} --port {port}

{domain}, *.{domain} {{
    reverse_proxy localhost:{port}
}}
"#
    )
}

/// Run the caddy command
pub fn run(
    domain: String,
    port: u16,
    output: Option<PathBuf>,
    do_install: bool,
    systemd: bool,
) -> Result<()> {
    // Install Caddy if requested
    if do_install {
        install_caddy()?;
    }

    // Generate Caddyfile
    let caddyfile = generate_caddyfile(&domain, port);

    // Output to file or stdout
    match output {
        Some(path) => {
            std::fs::write(&path, &caddyfile)
                .with_context(|| format!("Failed to write Caddyfile to {}", path.display()))?;
            println!("Caddyfile written to: {}", path.display());
        }
        None if systemd => {
            // When enabling systemd, write to default location
            if !is_root() {
                anyhow::bail!(
                    "Writing to {} requires root privileges.\n\
                    Run with sudo or specify --output for a different location.",
                    CADDYFILE_PATH
                );
            }

            // Create parent directory if needed
            if let Some(parent) = std::path::Path::new(CADDYFILE_PATH).parent() {
                std::fs::create_dir_all(parent)?;
            }

            // Create log directory
            let log_dir = format!("/var/log/caddy");
            std::fs::create_dir_all(&log_dir)?;

            std::fs::write(CADDYFILE_PATH, &caddyfile)
                .with_context(|| format!("Failed to write Caddyfile to {}", CADDYFILE_PATH))?;
            println!("Caddyfile written to: {}", CADDYFILE_PATH);
        }
        None => {
            // Print to stdout
            println!("{}", caddyfile);
            println!("\n# To use this config:");
            println!("# 1. Save to Caddyfile or /etc/caddy/Caddyfile");
            println!("# 2. Run: caddy run --config Caddyfile");
            println!("# Or use: ten caddy --domain {} --output /etc/caddy/Caddyfile", domain);
            return Ok(());
        }
    }

    // Enable systemd service if requested
    if systemd {
        enable_caddy_systemd()?;
    }

    Ok(())
}

/// Install Caddy via package manager
fn install_caddy() -> Result<()> {
    println!("Installing Caddy...\n");

    // Detect OS and package manager
    if cfg!(target_os = "linux") {
        // Try apt (Debian/Ubuntu)
        if Command::new("which").arg("apt").output()?.status.success() {
            println!("  Using apt package manager...");

            // Add Caddy repository
            println!("  Adding Caddy repository...");
            run_command(
                "sh",
                &[
                    "-c",
                    "apt install -y debian-keyring debian-archive-keyring apt-transport-https curl && \
                     curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/gpg.key' | gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg && \
                     curl -1sLf 'https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt' | tee /etc/apt/sources.list.d/caddy-stable.list"
                ],
            ).context("Failed to add Caddy repository")?;

            println!("  Installing Caddy package...");
            run_command("apt", &["update"])?;
            run_command("apt", &["install", "-y", "caddy"])?;

            println!("\n[OK] Caddy installed successfully!");
            return Ok(());
        }

        // Try dnf (Fedora/RHEL)
        if Command::new("which").arg("dnf").output()?.status.success() {
            println!("  Using dnf package manager...");
            run_command(
                "dnf",
                &["install", "-y", "'dnf-command(copr)'"],
            )?;
            run_command("dnf", &["copr", "enable", "@caddy/caddy", "-y"])?;
            run_command("dnf", &["install", "-y", "caddy"])?;
            println!("\n[OK] Caddy installed successfully!");
            return Ok(());
        }

        // Try yum (older RHEL/CentOS)
        if Command::new("which").arg("yum").output()?.status.success() {
            println!("  Using yum package manager...");
            run_command("yum", &["install", "-y", "yum-plugin-copr"])?;
            run_command("yum", &["copr", "enable", "@caddy/caddy", "-y"])?;
            run_command("yum", &["install", "-y", "caddy"])?;
            println!("\n[OK] Caddy installed successfully!");
            return Ok(());
        }

        // Try pacman (Arch)
        if Command::new("which").arg("pacman").output()?.status.success() {
            println!("  Using pacman package manager...");
            run_command("pacman", &["-S", "--noconfirm", "caddy"])?;
            println!("\n[OK] Caddy installed successfully!");
            return Ok(());
        }

        anyhow::bail!(
            "Could not detect package manager.\n\
            Install Caddy manually: https://caddyserver.com/docs/install"
        );
    } else {
        anyhow::bail!(
            "Automatic Caddy installation not supported on this OS.\n\
            Install manually: https://caddyserver.com/docs/install"
        );
    }
}

/// Enable Caddy as a systemd service
fn enable_caddy_systemd() -> Result<()> {
    if !is_root() {
        anyhow::bail!(
            "Enabling systemd service requires root privileges.\n\
            Run with sudo."
        );
    }

    println!("\nEnabling Caddy systemd service...");

    // Reload systemd daemon
    run_command("systemctl", &["daemon-reload"])?;

    // Enable and start Caddy
    run_command("systemctl", &["enable", "caddy"])?;
    run_command("systemctl", &["restart", "caddy"])?;

    // Check status
    std::thread::sleep(std::time::Duration::from_secs(1));

    let status = Command::new("systemctl")
        .args(["is-active", "caddy"])
        .output()?;

    if status.status.success() {
        println!("\n[OK] Caddy enabled and running!");
        println!("     HTTPS will be automatically configured on first request.");
        println!("\n  Manage with:");
        println!("    systemctl status caddy   # Check status");
        println!("    systemctl restart caddy  # Restart");
        println!("    journalctl -u caddy -f   # View logs");
    } else {
        println!("\n[WARN] Caddy may not be running. Check with:");
        println!("       systemctl status caddy");
        println!("       journalctl -u caddy");
    }

    Ok(())
}

/// Check if running as root
fn is_root() -> bool {
    #[cfg(unix)]
    {
        unsafe { libc::geteuid() == 0 }
    }
    #[cfg(not(unix))]
    {
        false
    }
}

/// Run a command and return result
fn run_command(cmd: &str, args: &[&str]) -> Result<()> {
    let status = Command::new(cmd)
        .args(args)
        .status()
        .with_context(|| format!("Failed to run: {} {}", cmd, args.join(" ")))?;

    if !status.success() {
        anyhow::bail!("Command failed: {} {}", cmd, args.join(" "));
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_caddyfile_basic() {
        let caddyfile = generate_caddyfile("example.com", 8080);

        // Check domain and wildcard
        assert!(caddyfile.contains("example.com, *.example.com {"));

        // Check reverse proxy
        assert!(caddyfile.contains("reverse_proxy localhost:8080"));

        // Check features
        assert!(caddyfile.contains("encode gzip zstd"));
        assert!(caddyfile.contains("log {"));
    }

    #[test]
    fn test_generate_caddyfile_custom_port() {
        let caddyfile = generate_caddyfile("myapp.io", 3000);

        assert!(caddyfile.contains("myapp.io, *.myapp.io {"));
        assert!(caddyfile.contains("reverse_proxy localhost:3000"));
    }

    #[test]
    fn test_generate_caddyfile_logging() {
        let caddyfile = generate_caddyfile("example.com", 8080);

        // Check logging configuration
        assert!(caddyfile.contains("/var/log/caddy/example.com.log"));
        assert!(caddyfile.contains("roll_size 100mb"));
        assert!(caddyfile.contains("roll_keep 5"));
    }

    #[test]
    fn test_generate_caddyfile_minimal() {
        let caddyfile = generate_caddyfile_minimal("example.com", 8080);

        // Should be simpler
        assert!(caddyfile.contains("example.com, *.example.com {"));
        assert!(caddyfile.contains("reverse_proxy localhost:8080"));

        // Should NOT have logging
        assert!(!caddyfile.contains("log {"));
    }

    #[test]
    fn test_caddyfile_has_https_comment() {
        let caddyfile = generate_caddyfile("example.com", 8080);

        // Should mention HTTPS
        assert!(caddyfile.contains("Automatic HTTPS"));
        assert!(caddyfile.contains("Let's Encrypt"));
    }

    #[test]
    fn test_caddyfile_has_wildcard_comment() {
        let caddyfile = generate_caddyfile("example.com", 8080);

        // Should mention wildcard routing
        assert!(caddyfile.contains("Wildcard subdomain"));
    }

    #[test]
    fn test_caddyfile_subdomain_format() {
        let caddyfile = generate_caddyfile("tenant.io", 9000);

        // Format should be: domain, *.domain
        assert!(caddyfile.contains("tenant.io, *.tenant.io {"));
    }
}
