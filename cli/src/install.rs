//! systemd installation for tenement
//!
//! Generates and installs a systemd unit file to run tenement as a service.
//! Optionally installs and configures Caddy as a reverse proxy with TLS.

use anyhow::{Context, Result};
use std::path::{Path, PathBuf};
use std::process::Command;

use crate::caddy;

/// Paths for systemd installation
const SYSTEMD_UNIT_PATH: &str = "/etc/systemd/system/tenement.service";
const BINARY_INSTALL_PATH: &str = "/usr/local/bin/ten";
const CONFIG_DIR: &str = "/etc/tenement";
const DATA_DIR: &str = "/var/lib/tenement";

/// Generate the systemd unit file content
pub fn generate_unit(domain: &str, port: u16, config_path: &Path) -> String {
    let binary_path = BINARY_INSTALL_PATH;
    let config_path_str = config_path.display();

    format!(
        r#"# Tenement Process Supervisor
# Generated by: ten install --domain {domain} --port {port}
# Manage with: systemctl [start|stop|restart|status] tenement

[Unit]
Description=Tenement Process Supervisor
Documentation=https://github.com/anthropics/tenement
After=network.target

[Service]
Type=simple
ExecStart={binary_path} serve --port {port} --domain {domain}
WorkingDirectory={DATA_DIR}
Restart=always
RestartSec=5

# Environment
Environment=TENEMENT_CONFIG={config_path_str}
Environment=RUST_LOG=info

# Security hardening
NoNewPrivileges=true
ProtectSystem=strict
ProtectHome=true
ReadWritePaths={DATA_DIR}
PrivateTmp=true

[Install]
WantedBy=multi-user.target
"#
    )
}

/// Install tenement as a systemd service
/// Optionally installs Caddy as a reverse proxy with automatic TLS
pub fn install(
    domain: String,
    port: u16,
    config: Option<PathBuf>,
    dry_run: bool,
    with_caddy: bool,
    dns_provider: Option<String>,
) -> Result<()> {
    // Find or use specified config file
    let config_path = match config {
        Some(p) => {
            if !p.exists() {
                anyhow::bail!("Config file not found: {}", p.display());
            }
            p.canonicalize().context("Failed to resolve config path")?
        }
        None => {
            // Find tenement.toml in current directory
            let cwd = std::env::current_dir()?;
            let default_config = cwd.join("tenement.toml");
            if !default_config.exists() {
                anyhow::bail!(
                    "No tenement.toml found. Create one or specify --config path.\n\
                    Example:\n\n\
                    [service.api]\n\
                    command = \"./api\"\n\
                    socket = \"/tmp/api-{{id}}.sock\"\n"
                );
            }
            default_config.canonicalize()?
        }
    };

    // Generate unit file content
    let dest_config = PathBuf::from(CONFIG_DIR).join("tenement.toml");
    let unit_content = generate_unit(&domain, port, &dest_config);

    if dry_run {
        println!("=== Dry run - would perform these actions ===\n");
        println!("1. Copy binary to {}", BINARY_INSTALL_PATH);
        println!("2. Create directory {}", CONFIG_DIR);
        println!("3. Copy config to {}", dest_config.display());
        println!("4. Create directory {}", DATA_DIR);
        println!("5. Create systemd unit at {}", SYSTEMD_UNIT_PATH);
        if with_caddy {
            println!("6. Install Caddy (if not present)");
            println!("7. Generate Caddyfile at /etc/caddy/Caddyfile");
            println!("8. Enable Caddy systemd service");
            if let Some(ref provider) = dns_provider {
                println!("   - Using DNS provider '{}' for per-process wildcards", provider);
            }
        }
        println!("\n=== Generated systemd unit ===\n");
        println!("{}", unit_content);
        if with_caddy {
            println!("\n=== Would generate Caddyfile (see `ten caddy` for preview) ===\n");
        }
        return Ok(());
    }

    // Check if running as root
    if !is_root() {
        anyhow::bail!(
            "Installation requires root privileges.\n\
            Run with sudo: sudo ten install --domain {} --port {}",
            domain, port
        );
    }

    println!("Installing tenement as systemd service...\n");

    // Step 1: Copy binary
    let current_exe = std::env::current_exe()?;
    println!("  Copying binary to {}...", BINARY_INSTALL_PATH);
    std::fs::copy(&current_exe, BINARY_INSTALL_PATH)
        .context("Failed to copy binary")?;

    // Make binary executable
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = std::fs::metadata(BINARY_INSTALL_PATH)?.permissions();
        perms.set_mode(0o755);
        std::fs::set_permissions(BINARY_INSTALL_PATH, perms)?;
    }

    // Step 2: Create config directory and copy config
    println!("  Creating config directory {}...", CONFIG_DIR);
    std::fs::create_dir_all(CONFIG_DIR)
        .context("Failed to create config directory")?;

    println!("  Copying config to {}...", dest_config.display());
    std::fs::copy(&config_path, &dest_config)
        .context("Failed to copy config")?;

    // Step 3: Create data directory
    println!("  Creating data directory {}...", DATA_DIR);
    std::fs::create_dir_all(DATA_DIR)
        .context("Failed to create data directory")?;

    // Step 4: Write systemd unit
    println!("  Creating systemd unit at {}...", SYSTEMD_UNIT_PATH);
    std::fs::write(SYSTEMD_UNIT_PATH, &unit_content)
        .context("Failed to write systemd unit")?;

    // Step 5: Reload systemd and enable service
    println!("  Reloading systemd daemon...");
    run_command("systemctl", &["daemon-reload"])?;

    println!("  Enabling tenement service...");
    run_command("systemctl", &["enable", "tenement"])?;

    println!("  Starting tenement service...");
    run_command("systemctl", &["start", "tenement"])?;

    // Wait a moment and check status
    std::thread::sleep(std::time::Duration::from_secs(1));

    let status = Command::new("systemctl")
        .args(["is-active", "tenement"])
        .output()?;

    if status.status.success() {
        println!("\n[OK] Tenement installed and running!");
        println!("     Dashboard: http://{}:{}", domain, port);
        println!("\n  Manage with:");
        println!("    systemctl status tenement  # Check status");
        println!("    systemctl restart tenement # Restart");
        println!("    journalctl -u tenement -f  # View logs");
    } else {
        println!("\n[WARN] Service may not be running. Check with:");
        println!("       systemctl status tenement");
        println!("       journalctl -u tenement");
    }

    // Install and configure Caddy if requested
    if with_caddy {
        println!("\n=== Setting up Caddy HTTPS reverse proxy ===\n");

        // Use the caddy module's run function with systemd enabled
        caddy::run(
            domain.clone(),
            port,
            Some(PathBuf::from("/etc/caddy/Caddyfile")),
            true,   // install caddy
            true,   // enable systemd
            dns_provider.clone(),
        )?;

        println!("\n=== Installation Complete ===");
        println!("\nYour setup:");
        println!("  - Tenement: Running on localhost:{}", port);
        println!("  - Caddy:    Reverse proxy with automatic HTTPS");
        println!("  - Access:   https://{}", domain);

        if let Some(ref provider) = dns_provider {
            println!("\n  DNS-01 Setup Required:");
            println!("  Set the DNS API token environment variable for Caddy:");
            println!("  Edit /etc/systemd/system/caddy.service to add:");
            println!("    Environment={}=your-api-token", caddy::dns_token_env_var(provider));
            println!("  Then: sudo systemctl daemon-reload && sudo systemctl restart caddy");
        }
    }

    Ok(())
}

/// Uninstall tenement systemd service
pub fn uninstall() -> Result<()> {
    if !is_root() {
        anyhow::bail!(
            "Uninstall requires root privileges.\n\
            Run with sudo: sudo ten uninstall"
        );
    }

    println!("Uninstalling tenement systemd service...\n");

    // Stop and disable service
    println!("  Stopping tenement service...");
    let _ = run_command("systemctl", &["stop", "tenement"]);

    println!("  Disabling tenement service...");
    let _ = run_command("systemctl", &["disable", "tenement"]);

    // Remove unit file
    if Path::new(SYSTEMD_UNIT_PATH).exists() {
        println!("  Removing systemd unit...");
        std::fs::remove_file(SYSTEMD_UNIT_PATH)?;
    }

    // Reload systemd
    println!("  Reloading systemd daemon...");
    run_command("systemctl", &["daemon-reload"])?;

    println!("\n[OK] Tenement service uninstalled.");
    println!("\n  Note: Config and data directories preserved:");
    println!("    {}", CONFIG_DIR);
    println!("    {}", DATA_DIR);
    println!("\n  To fully remove, also run:");
    println!("    rm {}", BINARY_INSTALL_PATH);
    println!("    rm -rf {} {}", CONFIG_DIR, DATA_DIR);

    Ok(())
}

/// Check if running as root
fn is_root() -> bool {
    #[cfg(unix)]
    {
        unsafe { libc::geteuid() == 0 }
    }
    #[cfg(not(unix))]
    {
        false
    }
}

/// Run a command and return result
fn run_command(cmd: &str, args: &[&str]) -> Result<()> {
    let status = Command::new(cmd)
        .args(args)
        .status()
        .with_context(|| format!("Failed to run: {} {}", cmd, args.join(" ")))?;

    if !status.success() {
        anyhow::bail!("Command failed: {} {}", cmd, args.join(" "));
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_unit_basic() {
        let config_path = PathBuf::from("/etc/tenement/tenement.toml");
        let unit = generate_unit("example.com", 8080, &config_path);

        assert!(unit.contains("[Unit]"));
        assert!(unit.contains("[Service]"));
        assert!(unit.contains("[Install]"));
        assert!(unit.contains("Description=Tenement Process Supervisor"));
        assert!(unit.contains("--port 8080"));
        assert!(unit.contains("--domain example.com"));
        assert!(unit.contains("TENEMENT_CONFIG=/etc/tenement/tenement.toml"));
        assert!(unit.contains("Restart=always"));
        assert!(unit.contains("WantedBy=multi-user.target"));
    }

    #[test]
    fn test_generate_unit_custom_port() {
        let config_path = PathBuf::from("/etc/tenement/tenement.toml");
        let unit = generate_unit("myapp.io", 3000, &config_path);

        assert!(unit.contains("--port 3000"));
        assert!(unit.contains("--domain myapp.io"));
    }

    #[test]
    fn test_generate_unit_security_settings() {
        let config_path = PathBuf::from("/etc/tenement/tenement.toml");
        let unit = generate_unit("example.com", 8080, &config_path);

        // Security hardening options
        assert!(unit.contains("NoNewPrivileges=true"));
        assert!(unit.contains("ProtectSystem=strict"));
        assert!(unit.contains("ProtectHome=true"));
        assert!(unit.contains("PrivateTmp=true"));
    }

    #[test]
    fn test_generate_unit_restart_settings() {
        let config_path = PathBuf::from("/etc/tenement/tenement.toml");
        let unit = generate_unit("example.com", 8080, &config_path);

        assert!(unit.contains("Restart=always"));
        assert!(unit.contains("RestartSec=5"));
    }

    #[test]
    fn test_generate_unit_working_directory() {
        let config_path = PathBuf::from("/etc/tenement/tenement.toml");
        let unit = generate_unit("example.com", 8080, &config_path);

        assert!(unit.contains("WorkingDirectory=/var/lib/tenement"));
    }

    #[test]
    fn test_generate_unit_network_dependency() {
        let config_path = PathBuf::from("/etc/tenement/tenement.toml");
        let unit = generate_unit("example.com", 8080, &config_path);

        assert!(unit.contains("After=network.target"));
    }

    #[test]
    fn test_install_missing_config() {
        let result = install(
            "example.com".to_string(),
            8080,
            Some(PathBuf::from("/nonexistent/config.toml")),
            true,   // dry_run
            false,  // with_caddy
            None,   // dns_provider
        );
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not found"));
    }
}
